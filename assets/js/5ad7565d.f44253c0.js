"use strict";(self.webpackChunkstudy_notes=self.webpackChunkstudy_notes||[]).push([[5883],{3905:function(e,n,r){r.d(n,{Zo:function(){return p},kt:function(){return v}});var t=r(67294);function o(e,n,r){return n in e?Object.defineProperty(e,n,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[n]=r,e}function s(e,n){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),r.push.apply(r,t)}return r}function l(e){for(var n=1;n<arguments.length;n++){var r=null!=arguments[n]?arguments[n]:{};n%2?s(Object(r),!0).forEach((function(n){o(e,n,r[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):s(Object(r)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(r,n))}))}return e}function i(e,n){if(null==e)return{};var r,t,o=function(e,n){if(null==e)return{};var r,t,o={},s=Object.keys(e);for(t=0;t<s.length;t++)r=s[t],n.indexOf(r)>=0||(o[r]=e[r]);return o}(e,n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(t=0;t<s.length;t++)r=s[t],n.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}var a=t.createContext({}),c=function(e){var n=t.useContext(a),r=n;return e&&(r="function"==typeof e?e(n):l(l({},n),e)),r},p=function(e){var n=c(e.components);return t.createElement(a.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},m=t.forwardRef((function(e,n){var r=e.components,o=e.mdxType,s=e.originalType,a=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),m=c(r),v=o,f=m["".concat(a,".").concat(v)]||m[v]||u[v]||s;return r?t.createElement(f,l(l({ref:n},p),{},{components:r})):t.createElement(f,l({ref:n},p))}));function v(e,n){var r=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var s=r.length,l=new Array(s);l[0]=m;var i={};for(var a in n)hasOwnProperty.call(n,a)&&(i[a]=n[a]);i.originalType=e,i.mdxType="string"==typeof e?e:o,l[1]=i;for(var c=2;c<s;c++)l[c]=r[c];return t.createElement.apply(null,l)}return t.createElement.apply(null,r)}m.displayName="MDXCreateElement"},29600:function(e,n,r){r.r(n),r.d(n,{assets:function(){return p},contentTitle:function(){return a},default:function(){return v},frontMatter:function(){return i},metadata:function(){return c},toc:function(){return u}});var t=r(87462),o=r(63366),s=(r(67294),r(3905)),l=["components"],i={},a="\u5b9e\u73b0Promise",c={unversionedId:"promise/implement",id:"promise/implement",title:"\u5b9e\u73b0Promise",description:"Promise.prototype.catch",source:"@site/fe/promise/implement.mdx",sourceDirName:"promise",slug:"/promise/implement",permalink:"/study-notes/fe/promise/implement",tags:[],version:"current",lastUpdatedBy:"Rain120",lastUpdatedAt:1648021720,formattedLastUpdatedAt:"3/23/2022",frontMatter:{},sidebar:"sidebar",previous:{title:"\u6027\u80fd\u6307\u6807",permalink:"/study-notes/fe/optimize/performance"},next:{title:"\u4e00\u4e9b\u5c0f\u7684\u77e5\u8bc6\u70b9",permalink:"/study-notes/fe/promise/little-knowledge"}},p={},u=[{value:"Promise.prototype.catch",id:"promiseprototypecatch",level:2},{value:"Promise.prototype.finally",id:"promiseprototypefinally",level:2},{value:"Promise.prototype.retry",id:"promiseprototyperetry",level:2},{value:"Promise.race",id:"promiserace",level:2},{value:"Promise.all",id:"promiseall",level:2},{value:"Promise.allSettled",id:"promiseallsettled",level:2},{value:"Promise.any",id:"promiseany",level:2},{value:"wrapAbort",id:"wrapabort",level:2},{value:"promisify",id:"promisify",level:2},{value:"\u5b98\u65b9\u7528\u4f8b\u6d4b\u8bd5",id:"\u5b98\u65b9\u7528\u4f8b\u6d4b\u8bd5",level:2},{value:"\u6d4b\u8bd5",id:"\u6d4b\u8bd5",level:2}],m={toc:u};function v(e){var n=e.components,r=(0,o.Z)(e,l);return(0,s.kt)("wrapper",(0,t.Z)({},m,r,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"\u5b9e\u73b0promise"},"\u5b9e\u73b0Promise"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"const STATUS = {\n    PENDING: 'PENDING',\n    FULFILLED: 'FULFILLED',\n    REJECTED: 'REJECTED',\n}\n\nclass Promise {\n    constructor(executor) {\n        this.status = STATUS.PENDING;\n        this.value = null;\n        this.reason = null;\n\n        this.onResolvedList = [];\n        this.onRejectList = [];\n\n        const resolve = (value) => {\n            if (value instanceof Promise) {\n                return value.then(resolve, reject);\n            }\n\n            this.status = STATUS.FULFILLED;\n            this.value = value;\n\n            this.onResolvedList.forEach(cb => {\n                cb && cb();\n            });\n        }\n\n        const reject = (reason) => {\n            this.status = STATUS.REJECTED;\n            this.reason = reason;\n\n            this.onRejectList.forEach(cb => {\n                cb && cb();\n            });\n        }\n\n        try {\n            executor && executor(resolve, reject);\n        } catch (error) {\n            reject(error);\n        }\n    }\n\n    static resolve (value) {\n        return new Promise((resolve, reject) => {\n            resolve(value);\n        });\n    }\n\n    static reject (value) {\n        return new Promise((resolve, reject) => {\n            reject(value);\n        });\n    }\n\n    // 1. x === promise(\u5b83\u672c\u8eab) => error\n    // 2. x => value => value\n    // 3. x \u662f promise =>\n    //    3.1 => x.then =>\n    //           3.1.1 => function => value or error => resolve(value) or reject(error)\n    //           3.1.2 => value => value\n    resolvePromise (promise, x, resolve, reject) {\n        if (x === promise) {\n            return reject(new TypeError('Chaining cycle detected for promise #<Promise>'));\n        }\n\n        let called;\n\n        const beCalled = called => {\n            if (called) {\n                return;\n            }\n\n            called = true;\n        }\n\n        if ((typeof x === 'object' && x !== null) || (typeof x === 'function')) {\n            const then = x.then;\n\n            try {\n                if (typeof then === 'function') {\n                    then.call(\n                        x,\n                        y => {\n                            beCalled(called);\n                            resolvePromise(promise, y, resolve, reject);\n                        },\n                        e => {\n                            beCalled(called);\n                            reject(e);\n                        }\n                    );\n                } else {\n                    resolve(x);\n                }\n            } catch (error) {\n                beCalled(called);\n                reject(error);\n            }\n        } else {\n            resolve(x);\n        }\n    }\n\n    then (onFulfilled, onRejected) {\n        onFulfilled = typeof onFulfilled === 'function'\n            ? onFulfilled\n            : value => value;\n\n        onRejected = typeof onRejected === 'function'\n            ? onRejected\n            : error => {\n                throw error\n            };\n\n        const promise = new Promise((resolve, reject) => {\n            if (this.status === STATUS.FULFILLED) {\n                setTimeout(() => {\n                    try {\n                        const x = onFulfilled(this.value)\n                        this.resolvePromise(promise, x, resolve, reject);\n                    } catch (error) {\n                        reject(error);\n                    }\n                });\n            }\n\n            if (this.status === STATUS.REJECTED) {\n                try {\n                    setTimeout(() => {\n                        try {\n                            const x = onRejected(this.reason)\n                            this.resolvePromise(promise, x, resolve, reject);\n                        } catch (error) {\n                            reject(error);\n                        }\n                    });\n\n                } catch (error) {\n                    reject(error);\n                }\n            }\n\n            if (this.status === STATUS.PENDING) {\n                try {\n                    this.onResolvedList.push(() => {\n                        setTimeout(() => {\n                            try {\n                                const x = onFulfilled(this.value)\n                                this.resolvePromise(promise, x, resolve, reject);\n                            } catch (error) {\n                                reject(error);\n                            }\n                        });\n                    });\n\n                    this.onRejectList.push(() => {\n                        setTimeout(() => {\n                            try {\n                                const x = onRejected(this.reason)\n                                this.resolvePromise(promise, x, resolve, reject);\n                            } catch (error) {\n                                reject(error);\n                            }\n                        });\n                    });\n                } catch (error) {\n                    reject(error);\n                }\n            }\n        });\n\n        return promise;\n    }\n}\n")),(0,s.kt)("h2",{id:"promiseprototypecatch"},"Promise.prototype.catch"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"Promise.prototype.catch = cb => {\n    if (typeof cb !== 'function') {\n        return Promise.reject(new TypeError(`${cb} is not a function`));\n    }\n\n    return this.then(null, cb);\n}\n")),(0,s.kt)("h2",{id:"promiseprototypefinally"},"Promise.prototype.finally"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"Promise.prototype.finally = cb => {\n    if (typeof cb !== 'function') {\n        return Promise.reject(new TypeError(`${cb} is not a function`));\n    }\n\n    return this.then(\n        value => Promise.resolve(cb()).then(() => value),\n        reason => Promise.resolve(cb()).then(() => { throw reason; }),\n    );\n}\n")),(0,s.kt)("h2",{id:"promiseprototyperetry"},"Promise.prototype.retry"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"Promise.prototype.retry = (cb, times = 1) => {\n    if (typeof cb !== 'function') {\n        return Promise.reject(new TypeError(`${cb} is not a function`));\n    }\n\n    return new Promise((resolve, reject) => {\n        while(times--) {\n            try {\n                Promise.resolve(cb()).then(value => {\n                    resolve(value);\n                    break;\n                });\n            } catch (error) {\n                console.log(`Retry in the ${times}\\'s timers.`)\n            }\n        }\n    }).catch (error) {\n        reject(error);\n    }\n}\n")),(0,s.kt)("h2",{id:"promiserace"},"Promise.race"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"Promise.race = values => {\n    if (!Array.isArray(values)) {\n        const type = typeof values;\n        return new TypeError(`TypeError: ${type} ${values} is not iterable`)\n    }\n\n    return new Promise((resolve, reject) => {\n        for (let i = 0; i < values.length; i++) {\n            const value = values[i];\n\n            Promise.resolve(value).then(\n                val => resolve(val),\n                reject\n            );\n\n            // if (typeof value === 'function') {\n            //     value.then(val => resolve(val), reject);\n            // } else {\n            //     resolve(value);\n            // }\n        }\n    });\n}\n")),(0,s.kt)("h2",{id:"promiseall"},"Promise.all"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"Promise.all = values => {\n    if (!Array.isArray(values)) {\n        const type = typeof values;\n        return new TypeError(`TypeError: ${type} ${values} is not iterable`)\n    }\n\n    return new Promise((resolve, reject) => {\n        const res = [];\n        const order = 0;\n\n        const processed = (value, i) => {\n            res[i] = value;\n\n            if (++order === values.length) {\n                resolve(res);\n            }\n        }\n\n        for (let i = 0; i < values.length; i++) {\n            const value = values[i];\n\n            Promise.resolve(value).then(\n                val => processed(val, i),\n                reject\n            );\n\n            // if (typeof value === 'function') {\n            //     value.then(value => processed(value, i), reject);\n            // } else {\n            //     processed(value, i);\n            // }\n        }\n    });\n}\n")),(0,s.kt)("h2",{id:"promiseallsettled"},"Promise.allSettled"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"// https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled\nPromise.allSettled = promises => {\n    if (!Array.isArray(promises)) {\n        const type = typeof promises;\n        return new TypeError(`TypeError: ${type} ${promises} is not iterable`)\n    }\n\n    if (promises.length === 0) {\n        return Promise.resolve([]);\n    }\n\n    return Promise.all(promises.map(promise => {\n        return Promise.resolve(promise).then(\n            value => ({ status: 'fulfilled', value }),\n            reason => ({ status: 'rejected', reason }),\n        );\n    }));\n}\n")),(0,s.kt)("h2",{id:"promiseany"},"Promise.any"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"// https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/any\nPromise.any = promises => {\n    if (!Array.isArray(promises)) {\n        const type = typeof promises;\n        return new TypeError(`TypeError: ${type} ${promises} is not iterable`)\n    }\n\n    if (promises.length === 0) {\n        return Promise.reject(new TypeError('any(): array must not be empty'));\n    }\n\n    return new Promise((resolve, reject) => {\n        let index = 0;\n        const rejected = [];\n\n        const onRejected = (reason, i) => {\n            index++;\n            rejected[index] = reason;\n\n            if (index === promises.length) {\n                reject(new AggregateError('No Promise in Promise.any was resolved'));\n            }\n        }\n\n        for (let i = 0; i < promises.length; i++) {\n            const value = promises[i];\n\n            Promise.resolve(value).then(\n                resolve,\n                reason => onRejected(reason, i)\n            );\n        }\n    });\n}\n")),(0,s.kt)("h2",{id:"wrapabort"},"wrapAbort"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"// \u4e2d\u65ad\nfunction wrapAbort (promise) {\n    let abort;\n\n    const abortPromise = new Promise((resolve, reject) => {\n        abort = reject;\n    });\n\n    let p = Promise.race([promise, abortPromise]);\n\n    return p;\n}\n")),(0,s.kt)("h2",{id:"promisify"},"promisify"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"function promisify (fn) {\n    return (...args) => {\n        return new Promise((resolve, reject) => {\n            fn(\n                ...args,\n                (reason, value) => {\n                    if (reason) {\n                        reject(reason);\n                    }\n\n                    resolve(value);\n                }\n            );\n        })\n    }\n}\n")),(0,s.kt)("h2",{id:"\u5b98\u65b9\u7528\u4f8b\u6d4b\u8bd5"},"\u5b98\u65b9\u7528\u4f8b\u6d4b\u8bd5"),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"npm i -D promises-aplus-tests")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"Promise.defer = Promise.deferred = function () {\n    let dfd = {};\n    dfd.promise = new Promise((resolve, reject) => {\n        dfd.resolve = resolve;\n        dfd.reject = reject;\n    })\n    return dfd;\n}\n\n")),(0,s.kt)("h2",{id:"\u6d4b\u8bd5"},"\u6d4b\u8bd5"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"const promise = new Promise((resolve, reject) => {\n    reject('\u5931\u8d25');\n}).then().then().then(data => {\n    console.log(data);\n}, err => {\n    console.log('err', err);\n})\n")))}v.isMDXComponent=!0}}]);